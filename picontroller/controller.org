* Objective

To define a useful library for people to control the robot without worrying too much about the low level implementation.
Effectively, think high level and let my library deal with low level control of motor controllers.

* Direction
** Compass
So the motor controller has directions expressed as numbers but I'd rather have programmers use more intuitive units.
This is why the convertDirectionsToNumber function exists - you can think in terms on North, South or North-East and write code like that.

Keep in mind that all directions are in terms of the robot's frame of reference and not the frame of reference of the arena.

|-----------+--------|
| Direction | Number |
|-----------+--------|
| N         |      1 |
| NE        |      2 |
| E         |      3 |
| SE        |      4 |
| S         |      5 |
| SW        |      6 |
| W         |      7 |
| NW        |      8 |
| CW        |      9 |
| CCW       |     10 |
|-----------+--------|

#+NAME: direction
#+BEGIN_SRC python :tangle direction/compass.py 
class Compass(object):
  N, NE, E, SE, S, SW, W, NW = range(1,9)
  CW, CCW = range(9,11)


  def __init__(self,value):
    if isinstance(value,basestring):
      self.value = Compass.convert(value) #If the user enters in a string instead of a number or the class defined static variables, convert it to the string.
    elif 1 <= value <= 10:
      self.value = value
    else:
      raise CompassError

  def __repr__(self):
    if 1 <= self.value <= 10:
      return "Compass." + Compass.convert(self.value)  #Should return the string representation of the value
    else:
      raise CompassError('Value contained is unrepresentable.')
  @staticmethod
  def convert(direction = None):

    #Sanitizing inputs
    if direction == None:
        raise CompassError('No input. Please enter valid input')


    # If the input is a number, return a string
    if 1 <= direction <= 10:

      directionList = {
        1:"N",
        2:"NE",
        3:"E",
        4:"SE",
        5:"S",
        6:"SW",
        7:"W",
        8:"NW",
        9:"CW",
        10:"CCW"
      }
      direction_raw = directionList.get(direction, None)
      if direction_raw is not None:
          return direction_raw
      else:
          raise CompassError('Please enter valid integer number from 1 to 10')



    # If the input is a string, return a number
    if isinstance(direction, basestring):
      
      directionList = {
          # Actual Directions
          "N"   : Compass.N,
          "NE"  : Compass.NE,
          "E"   : Compass.E,
          "SE"  : Compass.SE,
          "S"   : Compass.S,
          "SW"  : Compass.SW,
          "W"   : Compass.W,
          "NW"  : Compass.NW,
          # Spins the robot
          "CW"  : Compass.CW,
          "CCW" : Compass.CCW
      }
      direction_raw = directionList.get(direction, None)
      if 1 <= direction_raw <= 10:
          return direction_raw
      else:
          raise CompassError('Invalid input. Please enter valid string')

      # Somehow, you've reached here. This should not happen but whatever, raise the error
      
      raise CompassError('Invalid input - input entered is neither string nor number')




# Defining keywords for people to use
# When this package is imported, the user should be able to use the keywords without worrying about refering to the correct class name.
# In short, they can use N, NW and so on without saying CompassDirection.N or anything like that.


N   = Compass.N
NE  = Compass.NE
E   = Compass.E
SE  = Compass.SE
S   = Compass.S
SW  = Compass.SW
W   = Compass.W
NW  = Compass.NW
CW  = Compass.CW
CCW = Compass.CCW
#+END_SRC 

*** CompassError
Compass Error exists because ValueError is kind of vague and I'd like my errors to be be a bit more specific. 
I'd heavily discourage anyone from using this error if they're not dealing with the Compass class directly.
#+BEGIN_SRC python :tangle direction/compass.py 

class CompassError(ValueError):
    def __init__(self,*args,**kwargs):
        ValueError.__init__(self,*args,**kwargs)

#+END_SRC
*** Unit Tests
#+BEGIN_SRC python :tangle tests/direction/compass.py

import unittest
import picontroller.direction.compass

print(N)


#+END_SRC

** Vector

So we're going to implment a quick and dirty wrapper around numpy's vectors so that I can use them wherever I need vectors. 
Also, I might change from numpy to a another library but who knows.

#+BEGIN_SRC python :tangle direction/vector.py
import numpy

#SDSDFDSFSD

class Vector(numpy.ndarray):

    def __new__(cls, x=None, y=None, info=None):

        # Sanitizing x and y values
        if x == None or y == None:
          raise VectorError('Incomplete vector input')

        def is_number(s):
            try:
                float(s)
                return True
            except VectorError:
                return False
        
        if not (is_number(x) and is_number(y)):
          raise VectorError('Incorrect vector input. Please use numbers only')
      
        # We need to make ndarray instance using x and y values.
        input_array = numpy.array([x,y])

        # We first cast to be our class type
        obj = numpy.asarray(input_array).view(cls)
        # add the new attribute to the created instance
        obj.info = info
        # Finally, we must return the newly created object:
        return obj

    def __array_finalize__(self, obj):
        # see InfoArray.__array_finalize__ for comments
        if obj is None: return
        self.info = getattr(obj, 'info', None)

    def __repr__(self):
        return "< "+str(self[0])+" "+str(self[1])+" >"

    def mag(self):
      return numpy.sqrt(self.dot(self))

if __name__=="__main__":
    start = Vector(1,2)
    finish = Vector(4,5)

    distance = finish - start
    print(distance)
#+END_SRC
*** VectorError
I like better named exceptions.
#+BEGIN_SRC python :tangle direction/vector.py

class VectorError(ValueError):
    def __init__(self,*args,**kwargs):
        ValueError.__init__(self,*args,**kwargs)

#+END_SRC

*** Unit tests
#+BEGIN_SRC python :tangle tests/direction/vector.py
import unittest

#from VectorDirection import VectorDirection

class VectorDirectionTestCase(unittest.TestCase):
    """Tests for Vector Direction."""

    def add(self):
        """Is five successfully determined to be prime?"""
        self.assertTrue()
#+END_SRC 

* Instruction

 So this is the function that sends instructions to the motor controller using the serial library.
 The serial port used is /dev/ttyACM0 with baud rate 9600.
 When using this particular function, please give directions as N, NW and the like.


So why are we not defining this as some kind of function? Because I'd like to be able to reuse commands as much as possible AND because it makes more sense to write down commands and then execute them whenever required instead of creating wrapper functions around one main function.
- Logger 
The logger is to see what instructions are actually sent to the robot - I'm guessing that we'll need to look at the logs at some point even if we write perfect code.
I've also written a nice bash script that clears the log instead of us having to delete the file manually - it will probably be incorporated into whatever cleanup scripts the other programmers come up with.

#+NAME: Instruction
#+BEGIN_SRC python :tangle instruction/instruction.py
import logging #This is to send logs of instructions sent directly to robot.
import serial # Serial interface to talk to robot's motor controllers

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# create a file handler
handler = logging.FileHandler('instruction.log')
handler.setLevel(logging.INFO)
logger.addHandler(handler)

class Instruction(object):
  def __init__(self,direction = None, power = None, time = None):
    
    
    # Serial interface. Gonna be hardcoded for now. I'm sorry, future Vi.
    self.ser = serial.Serial("/dev/ttyACM0", 9600) #The only interface we talk to.

    #sanitizing input
    if direction_input == None or power_input == None or time_input == None:
      raise ValueError('Invalid input. Please enter valid input.') # Honestly, we should be saying that the default setting is something. But I want the users to actually say something. They can put default values in later.

    if not (0 <= power <= 100):
      raise ValueError('Invalid input. Power is a quantity between 0 and 100.')

    if not (time >= 0):
      raise ValueError('Invalid input. Time must always be a positive quantity.')

    # Actually saving input.
    self.direction = direction
    self.power = power
    self.time = time

  def execute(self):
    
    def convertToSerialString(direction,power,time):
      return str(direction) + " " + str(power) + " " + str(time)

    instruction = convertToSerialString(self.direction,self.power,self.time)
    logger.info(instruction)
    self.ser.write(instruction)         #Actually send stuff to the robot.

  @staticmethod  
  def stop():
    Instruction(0,0,0).execute()
 #+END_SRC

*** InstructionError
Because this particular class is called really often and I'd like for my arguments to be better named.
#+BEGIN_SRC python :tangle instruction/instruction.py

#+END_SRC
*** Bash Script to clean logs
Bash script to clean the logs of whatever instructions are given to the robot.
#+BEGIN_SRC bash :tangle no



#+END_SRC
*** Unit Tests
#+BEGIN_SRC bash :tangle no



#+END_SRC

* Position
** Coordinate
 #+BEGIN_SRC python :tangle position/coordinate.py
import numpy
class Coordinate(numpy.ndarray):
    def __new__(cls, x=None, y=None, info=None):
        # Sanitizing x and y values
       if x == None or y == None:
         raise ValueError('Incomplete coordinate input')
       def is_number(s):
           try:
               float(s)
               return True
           except ValueError:
               return False
      
       if not (is_number(x) and is_number(y)):
         raise ValueError('Incorrect input. Please use numbers only')
    
       # We need to make ndarray instance using x and y values.
       input_array = numpy.array([x,y])
        # We first cast to be our class type
       obj = numpy.asarray(input_array).view(cls)
       # add the new attribute to the created instance
       obj.info = info
       # Finally, we must return the newly created object:
       return obj
    def __array_finalize__(self, obj):
       # see InfoArray.__array_finalize__ for comments
       if obj is None: return
       self.info = getattr(obj, 'info', None)

if __name__=="__main__":
    start = Coordinate(1,2)
    finish = Coordinate(4,5)
    print("The distance between start and finish is")
    distance = finish - start
    print(distance)
 #+END_SRC

* Robot

Acts as an adapter between the higher-level interface users use and the Instruction class that sends instructions to the robot.

The move function accepts three types of inputs - compass points, vector directions and coordinate points. All three types of inputs are logged and each one updates the current position of the robot.

#+BEGIN_SRC python :tangle robot/robot.py
import piController.position.coordinate as coordinate
import piController.direction.vector as vector
import piController.direction.compass as compass

class Robot(object):
#  def __init__(self):

  def __init__(self,position=None):
    if (position is None) or (type(position) is not Coordinate):
      raise ValueError('Initial location is not specified')
    self.position = position

  def move(self, direction=None,distance=None):
    
    if type(direction) is compass.Compass:
      # The user has given a compass point and expects us to move to that location. This is where things can get a littlw awry.
      directionMove(direction,distance)
    if type(direction) is vector.Vector:
      # The user has given a vector and expects us to move to that location. 
      #If the distance is not specified, simply take the length of the vector. If distance is specified, use the distance instead.
      vectorMove(direction,distance)



  
  def vectorMove(self,vector=None,distance=None):
    if vector is None:
      raise ValueError("The vector input is not specified.")
    if type(vector) is not vector.Vector:
      raise ValueError("The vector input needs to be a vector")

    if distance is None:
    # If distance is none, change distance to the magnitude of the vector and use that.
      distance = vector.mag()
      
    #Convert the vector input into its norm. We're just going to divide the vector by its magnitude.
    vector = vector/vector.mag()


  def directionMove(self,direction=None,distance=None):
    # So I'm going to convert the distance into power and time values. Not very clean but it should work for now.

    instruction = Instruction(direction = 1, power = 100, time = 1000)
    instruction.execute()
    instruction.stop()




    # Now, we need to convert a vector & distance into instructions for the robot. I'm implementing a naive way of doing it (assuming that 
#+END_SRC 


* IIR - Infinite Impulse Response

#+BEGIN_EXAMPLE
f = Sensor(initialPosition = arg1,      # Optional Argument of type numpy array
           parameter       = arg2       # Optional Argument of type float
          )

f.predict()       # Returns a list of position vectors
f.update(z)       # Plugs in a numpy array to update the Kalman filter with new measurementValues
#+END_EXAMPLE


#+BEGIN_SRC python :tangle filter/Sensor.py
import numpy as np

class Sensor(object):

  def __init__(self,parameter,initialEstimate,linearTransform, offset):

    if parameter is None:
      raise ValueError("No parameter passed to Sensor")
    elif not 0 <= parameter <= 1:
      raise ValueError("Parameter must lie between zero and one.")

    if initialEstimate is None:
      self.estimate = np.array([0.,   
                                0.,
                                0.,
                                0.,
                                0.,
                                0.,
                                0.,
                                0.])
    else:
      self.estimate = initialEstimate

    if linearTransform is None:
      self.linearTransform = np.array([1,0],
                                      [0,1])
    else:
      self.linearTransform = linearTransform


    if offset is None: 
      self.offset = np.array([0,0])
    else:
      self.offset = offset

  def update(self, current):
    if current is None:
      raise ValueError("No current measurement passed to the filter")
    self.estimate = self.estimate * (1. - self.parameter) + current * (self.parameter)
    
  def errorEstimate(self,distance):

    # insert a dict for the distance error estimates.
    # Make it a vectorized function for this.
    return distance

  def query(self):
    A = self.estimate         

    #Get the average of every two intervals.       
    A = (A[::2] + A[1::2]) / 2

    # Weight our measurements in terms of the error estimates
    eA = errorEstimate(A)
    denom = eA[:2] + eA[2:]
    denom = np.concat(denom,denom)
    A     = np.multiply(A,eA[2,3,0,1]) / denom

    # Finding the difference between every other element of form [C - A, D - B]
    coordinate = (A[2::2]  - A[0:(len(A) - 2):2]) / 2      # of form x & y

    # Converting our coordinate into something someone else can use intuitively
    coordinate = coordinate * linearTransform + offset
    coordinate = coordinate  //  self.resolution                 # divides it by the required resolution


    # Finding the "theta" of the inclination of the robot.
    A = self.estimate

    #Get the average of every two intervals.       
    A = A[::2] - A[1::2]
    A = A[np.argsort(eA)]       # Sort in terms of lower errorEstimate
    theta = np.sum(A[:2:1])

    ans["x"] = 
    return np.concat(coordinate,np.array([theta]))

#+END_SRC



















* Kalman Filter
This is definitely not a copy paste from the internet. Pinky promise. 

So we have a bunch of linear data with Gaussian noise. Best filter to use is a Kalman filter than gives us accurate-ish values.



** API Reference

It's pretty simple since you effectively have just two things - inserting data into the Kalman filter & querying it for an estimate.

#+BEGIN_EXAMPLE
f = Kalman(initialPosition = arg1,      # Optional Argument of type numpy array
           timeStep        = arg2       # Optional Argument of type float
           )

f.predict()       # Returns a list of position vectors
f.update(z)       # Plugs in a numpy array to update the Kalman filter with new measurementValues
#+END_EXAMPLE


#+BEGIN_SRC python :tangle filter/KalmanFilter.py :noweb yes
from filterpy.kalman import KalmanFilter
class Kalman(object):

  def __init__(self,initialPosition,timeStep):

    <<initializationKalman>>
    <<initialPositionMatrix>>
    <<stateTransitionMatrix>>
    <<measurementMatrix>>
    <<processNoiseMatrix>>
    <<measurementNoise>>

  def predict(self):
    stuff = self.f.predict()

    return [x = ,
            y = ,
            theta = ] 


  def update(self,z):
    if z is None:
      raise ValueError("You have passed no value to update the Kalman Filter")
    
    self.f.update(z)

#+END_SRC

** Kalman Filter Initialization
#+NAME: initializationKalman
#+BEGIN_SRC python  :noweb yes
# Number of types of data we're getting. Since the distance sensor only cares about position, we only use position
dimX = 2
# Number of distance sensor we have
dimZ = 1
self.f = KalmanFilter(dim_x=dimX, dim_z=dimZ)
#+END_SRC

** Initial Position Vector

The initial position vector serves as the initial guess about the robot's position. The closer we are to real life, the less time it takes for the Kalman filter to reach acceptable results.
We know that the initial velocities are always zero as the robot is at rest. The initial positions are something to figure out when it comes to actually testing out the robot.

My suggestion would be to either hardcode the position into this file or make an init file that takes in some position matrix.

The initial position vector is 16 * 1 in order to account for both the velocity & position of eight different sensors.

#+NAME: initialPositionMatrix
#+BEGIN_SRC python :noweb yes
# Initial Position & Velocity Matrix

if initialPosition is None: 
  self.f.x = np.array([0., 0.,             #1
                       0., 0.,             #2
                       0., 0.,             #3
                       0., 0.,             #4
                       0., 0.,             #5
                       0., 0.,             #6
                       0., 0.,             #7
                       0., 0. ])           #8
  # Insert warning over here when you figure out which library you're using.

elif isinstance(initialPosition,List):  
  initialPosition = nd.array(initialPosition) 
  self.f.x = initialPosition
  # Insert warning over passing non-numpy arrays into this function


else:
  self.f.x = initialPosition
  # You should really check if this is a numpy array and not some random bullshit.
#+END_SRC

** State Transition Matrix

The state transition matrix is used to model the relationships between the positions and velocities.

#+BEGIN_LATEX
\begin{equation}
x_i = x_i + x_i* * deltat
v_i = x_i*
\end{equation}
#+END_LATEX

The term delta t is the timestep between measurements. We could make it slower than the actual refresh rate of the sensors but it would be best to experiment with an actual value.

#+NAME: stateTransitionMatrix
#+BEGIN_SRC python :noweb yes
# State transition matrix
if timeStep is None:
  dt = 0.001     # Time step is in the order of milliseconds
else:
  dt = timeStep

self.f.F = np.array([[1., dt, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
                     [0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
                     [0., 0., 1., dt, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
                     [0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
                     [0., 0., 0., 0., 1., dt, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
                     [0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
                     [0., 0., 0., 0., 0., 0., 1., dt, 0., 0., 0., 0., 0., 0., 0., 0.],
                     [0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0.],
                     [0., 0., 0., 0., 0., 0., 0., 0., 1., dt, 0., 0., 0., 0., 0., 0.],
                     [0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0.],
                     [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., dt, 0., 0., 0., 0.],
                     [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0.],
                     [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., dt, 0., 0.],
                     [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],
                     [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., dt],
                     [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.]])
#+END_SRC     

** Measurement Matrix

The measurement matrix is a way to convert the matrices that the kalman filter uses into the matrices that we want to see. 
In our case, we only care about the positions given by the Kalman filter and not the velocity - dumping the velocity makes sense here.

matrixA is one way of converting a vector of cardinality 16 into a vector of cardinality 8 while skipping every second element.
#+NAME: measurementMatrix
#+BEGIN_SRC python :noweb yes
# Measurement function

# Effectively reduces the position & velocity vector to just a position vector
matrixA =  np.array([[1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
                     [0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
                     [0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
                     [0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
                     [0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0.],
                     [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0.],
                     [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0.],
                     [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0.]])

self.f.H = matrixA       # Why am I calling this matrixA instead of just assigning it directly? Because I might needto switch out stuff later. Fuck YAGNI.
#+END_SRC

** Process Noise

So the process noise is a a matrix that lists the variance between the different sensors. In reality, some sensors will have a high degree of covariance if they are on the same face ie they will have (almost) the same data.
For now, we've assumed that there is no dependence on each other because Vi is too fucking lazy to read theory.

#+NAME: processNoiseMatrix
#+BEGIN_SRC python :noweb yes
# The process noise is np.eye(dim_x) by default so you can just multiply by some constant
# This assumes that each sensor is independent from each other.
self.f.P *= 1000.
#+END_SRC
** Measurement Noise

No clue what this is. Philip, pls halp.
#+NAME: measurementNoise
#+BEGIN_SRC python :noweb yes
# Measurement noise
self.f.R = 5
#+END_SRC



** Old implementation
:ARCHIVE:
#+BEGIN_SRC python :tangle no

# filter/kalmanFilter.py

class KalmanFilter(object):

    def __init__(self, processVariance, estimatedMeasurementVariance):
        self.processVariance = processVariance
        self.estimatedMeasurementVariance = estimatedMeasurementVariance
        self.posteriEstimate = 0.0
        self.posteriErrorEstimate = 1.0

    def inputMeasurement(self, measurement):
        prioriEstimate = self.posteriEstimate
        prioriErrorEstimate = self.posteriErrorEstimate + self.processVariance

        blending_factor = prioriErrorEstimate / (prioriErrorEstimate + self.estimatedMeasurementVariance)
        self.posteriEstimate = prioriEstimate + blendingFactor * (measurement - prioriEstimate)
        self.posteriErrorEstimate = (1 - blendingFactor) * prioriErrorEstimate

    def getEstimate(self):
        return self.posteriEstimate


if __name__ == "__main__":
    import random
    iteration_count = 500

    actual_values     = [-0.37727 + j * j * 0.00001 for j in xrange(iteration_count)]
    noisy_measurement = [random.random() * 2.0 - 1.0 + actual_val for actual_val in actual_values]

    # in practice we would take our sensor, log some readings and get the
    # standard deviation
    import numpy
    measurement_standard_deviation = numpy.std([random.random() * 2.0 - 1.0 for j in xrange(iteration_count)])

    # The smaller this number, the fewer fluctuations, but can also venture off
    # course...
    process_variance = 1e-3
    estimated_measurement_variance = measurement_standard_deviation ** 2  # 0.05 ** 2
    kalman_filter = KalmanFilter(process_variance, estimated_measurement_variance)
    posteri_estimate_graph = []

    for iteration in xrange(1, iteration_count):
        kalman_filter.input_latest_noisy_measurement(noisy_measurement[iteration])
        posteri_estimate_graph.append(kalman_filter.get_latest_estimated_measurement())


    import pylab
    pylab.figure()
    pylab.plot(noisy_measurement, color='r', label='noisy measurements')
    pylab.plot(posteri_estimate_graph, 'b-', label='a posteri estimate')
    pylab.plot(actual_values, color='g', label='truth value')
    pylab.legend()
    pylab.xlabel('Iteration')
    pylab.ylabel('Voltage')
    pylab.show()

#+END_SRC
<<<<<<< Updated upstream
=======




* Library Information
Just doing normal python library stuff. Consider it unimportant unless someone complains that they can't access something.






>>>>>>> Stashed changes
